/*
    ! CODE MADE BY AI !
    This code was generated by Copilot (GPT-4o) after
    only being given the hydra.js source code to
    learn. It's insane what AI is able to do with such
    little information nowadays.
*/

const canvasId = 'game';

const game = new HydraCanvasLib(canvasId);

let paddle, ball, bricks;

function initGame() {
    // Paddle
    paddle = game.sprites.createNew((game.canvas.width - 100) / 2, game.canvas.height - 30, SimpleRenderers.rectangle(100, 20, 'blue'));
    paddle.collider = game.collision.makeSquareCollider(100, 20);

    // Ball
    ball = game.sprites.createNew(game.canvas.width / 2, game.canvas.height / 2, SimpleRenderers.circle(10, 'red'));
    ball.dx = 4; // Increased speed 10x
    ball.dy = -4; // Increased speed 10x
    ball.collider = game.collision.makeSquareCollider(20, 20); // Added collider to ball

    // Bricks
    bricks = [];
    const brickRows = 5;
    const brickCols = 8;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    for (let row = 0; row < brickRows; row++) {
        bricks[row] = [];
        for (let col = 0; col < brickCols; col++) {
            const x = col * (brickWidth + brickPadding) + brickOffsetLeft;
            const y = row * (brickHeight + brickPadding) + brickOffsetTop;
            const brick = game.sprites.createNew(x, y, SimpleRenderers.rectangle(brickWidth, brickHeight, 'green'));
            brick.collider = game.collision.makeSquareCollider(brickWidth, brickHeight);
            bricks[row][col] = brick;
        }
    }
}

function updateGame(deltaTime) {
    // Move paddle
    if (game.listen.isKey('ArrowLeft') && paddle.x > 0) {
        game.sprites.moveBy(paddle, -7, 0);
    }
    if (game.listen.isKey('ArrowRight') && paddle.x < game.canvas.width - paddle.collider.width) {
        game.sprites.moveBy(paddle, 7, 0);
    }

    // Move ball
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Ball collision with walls
    if (ball.x + ball.renderer.renderParams.radius > game.canvas.width || ball.x - ball.renderer.renderParams.radius < 0) {
        ball.dx = -ball.dx;
    }
    if (ball.y - ball.renderer.renderParams.radius < 0) {
        ball.dy = -ball.dy;
    } else if (ball.y + ball.renderer.renderParams.radius > game.canvas.height) {
        // Game over
        console.log("GAME OVER");
        document.location.reload();
    }

    // Ball collision with paddle
    if (game.collision.checkSquareCollision(ball, paddle)) {
        ball.dy = -ball.dy;
    }

    // Ball collision with bricks
    for (let row = 0; row < bricks.length; row++) {
        for (let col = 0; col < bricks[row].length; col++) {
            const brick = bricks[row][col];
            if (brick && game.collision.checkSquareCollision(ball, brick)) {
                ball.dy = -ball.dy;
                game.sprites.remove(brick);
                bricks[row][col] = null;
            }
        }
    }
}

initGame();
game.listen.addTicker(updateGame);
game.loop();